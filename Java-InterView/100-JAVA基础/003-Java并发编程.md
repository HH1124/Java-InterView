# 一、使用线程
有三种使用线程的方法：
- 实现 Runnable 接口；实现run方法
- 实现 Callable 接口；可以有返回值，返回值通过FutureTask封装
- 继承 Thread 类，复写Run方法
- 线程池的方式创建

## 实现 Runnable 接口
![image](E4C3F7B3AC1B45BEB928518A6ABAE3A9)
## 实现 Callable 接口
![image](18CB588534254E378A315F171AC00E52)
## 继承 Thread 类
![image](05A5C053B6F94E129019575FB13F0203)
## 实现接口 VS 继承 Thread
实现接口会更好一些，因为：

- Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
- 类可能只要求可执行就行，继承整个 Thread 类开销过大。
# 二、基础线程机制
## 线程池
- 线程是稀缺资源，不能频繁的创建。
- 解耦作用；线程的创建于执行完全分开，方便维护。
- 应当将其放入一个池子中，可以给其他任务进行复用。
- 阿里巴巴 Java 手册

![image](265822C5C4804CB7BEFF9F44C8209742)

### 池化技术
其中最核心的思想就是把宝贵的资源放到一个池子中；每次使用都从里面获取，用完之后又放回池子供其他人使用

## Executor
Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。

主要有三种 Executor：
- CachedThreadPool：一个任务创建一个线程；
- FixedThreadPool：所有任务只能使用固定大小的线程；
- SingleThreadExecutor：相当于大小为 1 的FixedThreadPool。

### 1.CachedThreadPool
创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

### 2.FixedThreadPool
创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。

### 3.SingleThreadExecutor
创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。

### 创建线程的方式
- Executors.newCachedThreadPool()
- Executors.newFixedThreadPool(nThreads)
- Executors.newSingleThreadExecutor()

**Executors 创建的线程池存在OOM的风险，不建议这样创建线程**

### Executors创建线程的弊端
- FixedThreadPool 和 SingleThreadExecutor ：**允许请求的队列长度为Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM**。

- CachedThreadPool 和 ScheduledThreadPool ：**允许创建的线程数量为 Integer.MAX_VALUE，可能会创建大量线程，从而导致OOM**。

## ThreadPoolExecutor（推荐）
- 常见的4个构造方法
![image](E8D1445044684C559E3D9DA704A6FA3D)
```
ThreadPoolExecutor(int corePoolSize,
                        int maximumPoolSize,
                        long keepAliveTime,
                        TimeUnit unit,
                        BlockingQueue<Runnable> workQueue) 
                        
```
### 构造参数说明
#### corePoolSize
核心线程数，默认情况下核心线程会一直存活

默认情况下，在创建了线程池后，线程池中的线程数为0,当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corepoolsizef后，就会把到达的任务放到绶存队列当中。

在创建了线程池后，默认情況下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了 **prestartallcorethreads()**或者**prestartCoreThreado** 方法，从这2个方法的名字就可以看出，是**预创建线程**的意思，即在没有任务到来之前就创建 corepoolsize个线程或者一个线程。

#### maximumPoolSize
线程池所能容纳的最大线程数.超过这个数的线程将被阻塞。
#### keepAliveTime
非核心线程的闲置超时时间，超过这个时间就会被回收。

默认情況下，只有当线程池中的线程数大于corepoolsize时，keepaliveTimeオ会起作用，直到线程池中的线程数不大于corepoolsize，

#### unit
指定keepAliveTime的单位，有7种取值。Timeunit.DAYS、 Timeunit. HOURS、Timeunit MINUTES 、Timeunit SECONDS 、Timeunit MILLISECONDS
#### workQueue
> https://www.cnblogs.com/feiyun126/p/7686302.html
- 线程池中的任务队列.
- 常用的有三种队列，SynchronousQueue,LinkedBlockingDeque,ArrayBlockingQueue。

##### SynchronousQueue
**没有容量，是无缓冲等待队列**，是一个**不存储元素**的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素。

拥有公平（FIFO）和非公平(LIFO)策略，

##### LinkedBlockingQueue
一个**无界缓存等待队列**。默认容量大小为Integer.MAX_VALUE，为2的31次幂 - 1。

这个队列需要注意的是，虽然通常称其为一个无界队列，但是**可以人为指定队列大小**

##### ArrayBlockingQueue
一个**有界缓存等待队列**，**可以指定缓存队列的大小**，当正在执行的线程数等于corePoolSize时，多余的元素缓存在ArrayBlockingQueue队列中等待有空闲的线程时继续执行，当ArrayBlockingQueue已满时，加入ArrayBlockingQueue失败，会开启新的线程去执行，当线程数已经达到最大的maximumPoolSizes时，再有新的元素尝试加入ArrayBlockingQueue时会报错。


## Daemon(守护线程)
守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。

当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。

main() 属于非守护线程。

在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。
## sleep()
Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。

sleep() 可能会抛出 **InterruptedException**，

多线程中，如果线程抛出异常，当前线程会被终结，而主线程和其他线程是不受影响的，是相对独立的。且线程抛出异常需要线程本身解决，而不是抛出到外。

JVM的这种设计源自于这样一种理念：“线程是独立执行的代码片断，线程的问题应该由线程自己来解决，而不要委托到外部。
## yield()
对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。


## ThreadLocal
创建线程局部变量的类

ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。

ThreadLocalMap存储变量
在ThreadLoalMap中，也是初始化一个大小16的Entry数组，Entry对象用来保存每一个key-value键值对，只不过这里的key永远都是ThreadLocal对象，是不是很神奇，通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key，放进了ThreadLoalMap中。

- 主要方法：
```java
    
    //  get()方法是用来获取ThreadLocal在当前线程中保存的变量副本
    public T get() { }  
    
    // set()用来设置当前线程中变量的副本
    //在进行get之前，必须先set，否则会报空指针异常；
　　//如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。
    public void set(T value) { }  
    
    // remove()用来移除当前线程中变量的副本
    public void remove() { }  
    
    // initialValue()是一个protected方法，一般是用来在使用时进行重写的,返回当前线程在当前ThreadLocal中的初始默认值
    // 该方法默认返回null，可以重写该方法（比如继承或实现一个匿名类）
    protected T initialValue() { }  

```
# 三、中断
一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。

但是不能中断 I/O 阻塞、synchronized 锁阻塞、Lock锁。
## interrupt()
interrupt不会中断正在执行的线程，而是将线程的中断标志位，修改为true，可以通过isInterrupted()方法来判断是否发生中断。

如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。

但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。

- 如果当前线程处于阻塞、限期等待或者无限期等待状态，执行interrupt()方法就是抛出InterruptedException异常，结束当前线程。
- 正常的线程执行interrupt()方法，则会修改中断标记位。

## interrupted
判断当前线程是否发生中断，并且重置中断标志位
## isInterrupted()
判断线程是否发生中断

### interrupted与isInterrupted区别
- interrupted()是static方法，调用的时候要用Thread.interrupted()
- isInterrupted()是实例方法，调用时要用线程的实例调用
- Thread.interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能；
- this.isInterrupted()：测试线程Thread对象是否已经是中断状态，但不清除状态标志。

## InterruptedException
发生 InterruptedException 异常的时候，会结束当前线程，并且将当前线程的中断状态置为false.

并且发生此异常是不能抛出的，因为更高层的代码并不能收到此异常，是需要在本地进行处理。

在捕获了InterruptedException异常之后，如果你什么也不想做，那么就将标志重新置为true，以便栈中更高层的代码能知道中断，并且对中断作出响应。

## Executor 的中断操作
调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。
# 四、互斥同步
Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。
## synchronized
## ReentrantLock
## 比较
### 1. 锁的实现
synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK实现的。
- synchronized不需要用户手动去释放锁，当synchronized代码执行完成后，系统会自动让线程释放对锁的占用；
- ReentrantLock则需要用户手动去释放锁，若没有主动释放锁，就有可能导致出现死锁现象。需要lock()、unlock()方法配合try/finally语句块来完成。底层通过 **AQS** 实现

### 2. 性能
新版本 Java 对 synchronized进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。

**synchronized锁优化见12章节**

> 乐观锁与悲观锁 https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484911&amp;idx=1&amp;sn=1d53616437f50b353e33edad6fda2e4f&source=41#wechat_redirect

> 自旋锁 https://zhuanlan.zhihu.com/p/40729293

### 3. 等待可中断
当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

ReentrantLock 可中断，而 synchronized 不行。
### 4. 公平锁
公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。

synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

### 5. 锁绑定多个条件
一个 ReentrantLock 可以同时绑定多个 Condition 对象。

ReentrantLock用来实现分组需要唤醒的线程们，可以精确唤醒，而不像synchronized那样随便唤醒一个线程或者全部线程。
## 使用选择
除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。
- synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。
- synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。

# 五、线程之间的协作
当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。
## join()
在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。
## wait() notify() notifyAll()
使用wait()方法等待线程满足运行条件时，会将当前线程挂起，其他线程运行使得这个条件满足时，其他线程就会调用notify()或者notifyAll(),来唤醒当前线程。

它们都属于 Object 的一部分，而不属于 Thread。

**只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。**

使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。



### wait() 和 sleep() 的区别
- wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
- wait() 会释放锁，sleep() 不会。

## await() signal() signalAll()
**java.util.concurrent**类库中提供了 **Condition** 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。

相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。

# 六、线程状态
一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。

## 新建（NEW）
创建后尚未启动。
## 可运行（RUNABLE）

## 阻塞（BLOCKED）
请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。

## 无限期等待（WAITING）
等待其它线程显式地唤醒。

阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。

## 限期等待（TIMED_WAITING）
无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。
## 死亡（TERMINATED）
可以是线程结束任务之后自己结束，或者产生了异常而结束。

# J.U.C - AQS
>Abstract Queued Synchronizer 抽象队列同步器
> https://www.cnblogs.com/waterystone/p/4920797.html

AQS定义了一套**多线程访问共享资源的同步器框架**，许多同步类实现都依赖于它。

AQS同时提供了互斥模式（exclusive）和共享模式（shared）两种不同的同步逻辑

Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。

不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。
## 底层实现

#### acquire(int)
acquire是一种以独占方式获取资源，如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。该方法是独占模式下线程获取共享资源的顶层入口。获取到资源后，线程就可以去执行其临界区代码了。

####  release(int)
release(int)方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。

#### acquireShared(int)
acquireShared(int)方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。

如果第一个线程拥有5个资源，而第二个线程需要6个资源，第三个需要1个资源，这时线程1释放，唤醒线程2，线程2发现资源不够，是不会唤醒线程3的，线程2会继续等待其他线程释放资源，AQS是严格保证按照入队顺序唤醒线程（保证公平，但降低了并发）。

#### releaseShared(int)
releaseShared(int)方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。


## 示例
#### ReentrantLock
以ReentrantLock为例，**state**初始化为0，表示未锁定状态。A线程Lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

#### CountDownLatch
再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。

## 共享模式的锁
#### CountDownLatch（倒计时锁）
> https://www.jianshu.com/p/e233bb37d2e6

用来控制一个或者多个线程等待多个线程。

维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。

#### CyclicBarrier（循环栅栏）
> https://www.jianshu.com/p/333fd8faa56e

用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。

和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。

CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用**reset() 方法可以循环使用**，所以它才叫做循环屏障。


#### Semaphore (信号量)
Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。（停车场）

#### Exchanger (交换机)
两个工作线程之间交换数据的封装工具类

就是一个线程在完成一定的事务后想与另一个线程交换数据，则第一个先拿出数据的线程会一直等待第二个线程，直到第二个线程拿着数据到来时才能彼此交换对应数据

可以看出，当一个线程到达 exchange 调用点时，如果其他线程此前已经调用了此方法，则其他线程会被调度唤醒并与之进行对象交换，然后各自返回；如果其他线程还没到达交换点，则当前线程会被挂起，直至其他线程到达才会完成交换并正常返回，或者当前线程被中断或超时返回。

# 十、Java内存模型(JMM)

Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。

## 主内存与工作内存
![image](E4967AECF5B043879099C2208599539F)

处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。

## 内存间交互操作

Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。
![image](CB7B1DFB96554706984BA2F2B1847887)

- read：把一个变量的值从主内存传输到工作内存中
- load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
- use：把工作内存中一个变量的值传递给执行引擎
- assign：把一个从执行引擎接收到的值赋给工作内存的变量
- store：把工作内存的一个变量的值传送到主内存中
- write：在 store 之后执行，把 store 得到的值放入主内存的变量中
- lock：作用于主内存的变量
- unlock

## 内存模型三大特性
### 原子性
指一个操作是不可中断的，即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰
### 可见性
指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。

主要有三种实现可见性的方式：  

- volatile
- synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
- final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。    
###  有序性
对于一个线程的执行代码而言，我们总是习惯地认为代码的执行时从先往后，依次执行的。

有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。

### 先行发生原则

# 十一、线程安全
## 不可变
不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。

不可变的类型：
- final 关键字修饰的基本数据类型
- String
- 枚举类型
- Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。
- 对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。
## 互斥同步
synchronized 和 ReentrantLock。

## 非阻塞同步
互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。

**悲观锁**：互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

**乐观锁**：随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步


### 1. CAS  比较并交换（Compare-and-Swap）
CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。
 
 #### ABA

如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。

J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。 
### 2. AtomicInteger
J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。

## 无同步方案
要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。

### 1. 栈封闭
**多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。**
```
public class StackClosedExample {
    public void add100() {
        int cnt = 0;
        for (int i = 0; i < 100; i++) {
            cnt++;
        }
        System.out.println(cnt);
    }
}
```

### 2. 线程本地存储（Thread Local Storage TLS）
如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

### 3. 可重入代码（Reentrant Code）
这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。

可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。

# 十二、锁优化
这里的锁优化主要是指 JVM 对 synchronized 的优化。
## 自旋锁
互斥同步进入阻塞状态的开销都很大，应该尽量避免

在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。

当一个线程在获取一个锁时，如果这个有线程在占用这个锁，那么当前线程就进行忙循环，他就会一直尝试获取这个锁，直到他拿到这个锁为止。这样就可以避免线程进去阻塞状态。

但是自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于获取锁定状态很短的场景。

在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由**前一次在同一个锁上的自旋次数**及**锁的拥有者的状态**来决定。



## 锁消除

锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。

锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。

- 举例：
		StringBuffer的append方法是一个同步方法，如果StringBuffer类型的变量是一个局部变量，则该变量就不会被其它线程所使用，即对局部变量的操作是不会发生线程不安全的问题。
		在这种情景下，JVM会在JIT编译时自动将append方法上的锁去掉。

### 逃逸分析
> 深入理解Java中的逃逸分析 https://blog.csdn.net/hollis_chuang/article/details/80922794

逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。
```
第一段代码中的sb就逃逸了，而第二段代码中的sb就没有逃逸。

public static StringBuffer craeteStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb;
}

public static String createStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb.toString();
}

```

Java的逃逸分析只发在JIT的即时编译，不在前期的静态编译中就进行

在Java代码运行时，通过JVM参数可指定是否开启逃逸分析，

-XX:+DoEscapeAnalysis ： 表示开启逃逸分析

-XX:-DoEscapeAnalysis ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis

#### 针对逃逸分析，JVM如何进行优化
##### 同步省略
- 经过逃逸分析算法，如果当前方法无逃逸发生，那么jvm就会取消对于当前方法的同步，这个取消同步的过程就叫同步省略，也叫**锁消除**。

##### 标量替换
- **标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。**
- 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个成员变量来代替。这个过程就是标量替换。
- 标量替换的好处就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。

##### 栈上分配
- 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识
- 如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。
- 现有的虚拟机中，并没有真正的实现栈上分配，而是通过标量替换实现的。
#### 为什么不在前期的静态编译中就进行？？
Java的分离编译和动态加载使得前期的静态编译的逃逸分析比较困难或收益较少，所以目前Java的逃逸分析只发在JIT的即时编译中，因为收集到足够的运行数据JVM可以更好的判断对象是否发生了逃逸。

引入了 JIT 技术后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。
## 锁粗化
将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，即将加锁的粒度放大。

举例：在for循环里的加锁/解锁操作，一般需要放到for循环外。

## 轻量级锁
- java6为了减少获取锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。
- 锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁、轻量级锁、重量级锁。
- 锁的状态会随着竞争情况逐渐升级，并且只可以升级而不能降级。

轻量级锁是相对于传统的重量级锁而言，它使用CAS操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。

优点：在没有多线程竞争的前提下，减少传统的重量级锁带来的性能损耗。  
          
缺点：竞争的线程如果始终得不到锁，自旋会消耗cpu。  
  
应用：追求响应时间，同步块执行速度非常快。  

### 轻量级锁的创建过程
![image](A8DE4F94ED064E44AF9180757701BB1D)


### 原理
当使用轻量级锁(锁标识位为00)时，线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中(注:锁记录中的标识字段称为Displaced Mark Word)。
			
将对象头中的MarkWord复制到栈桢中的锁记录中之后，虚拟机将尝试使用CAS将对象头中Mark Word替换为指向该线程虚拟机栈中锁记录的指针，此时如果没有线程占有锁或者没有线程竞争锁，则当前线程成功获取到锁，然后执行同步块中的代码。
			
如果在获取到锁的线程执行同步代码的过程中，另一个线程也完成了栈桢中锁记录的创建，并且已经将对象头中的MarkWord复制到了自己的锁记录中，然后尝试使用CAS将对象头中的MarkWord修改为指向自己的锁记录的指针，但是由于之前获取到锁的线程已经将对象头中的MarkWord修改过了(并且现在还在执行同步体中的代码,即仍然持有着锁)，所以此时对象头中的MarkWord与当前线程锁记录中MarkWord的值不同，导致CAS操作失败，然后该线程就会不停地循环使用CAS操作试图将对象头中的MarkWord替换为自己锁记录中MarkWord的值，(当循环次数或循环时间达到上限时停止循环)如果在循环结束之前CAS操作成功，那么该线程就可以成功获取到锁，如果循环结束之后依然获取不到锁，则锁获取失败，对象头中的MarkWord会被修改为指向重量级锁的指针，然后这个获取锁失败的线程就会被挂起，阻塞了。
			
当持有锁的那个线程执行完同步体之后，使用CAS操作将对象头中的MarkWord还原为最初的状态时(将对象头中指向锁记录的指针替换为Displaced Mark Word )，发现MarkWord已被修改为指向重量级锁的指针，因此CAS操作失败，该线程会释放锁并唤起阻塞等待的线程，开始新一轮夺锁之争，而此时，轻量级锁已经膨胀为重量级锁，所有竞争失败的线程都会阻塞，而不是自旋。

### 偏向锁
背景：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。

概念：核心思想就是锁会偏向第一个获取它的线程，如果在接下来的执行过程中没有其它的线程获取该锁，则持有偏向锁的线程永远不需要同步。

目的：偏向锁实际上是一种优化锁，其目的是为了减少数据在无竞争情况下的性能损耗。

原理：
- 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID。
- 以后该线程在进入和退出同步块时就不需要进行CAS操作来加锁和解锁，只需简单地判断一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。

偏向锁的获取：
- 访问Mark Word中偏向锁的标识位是否为1，如果是1，则确定为偏向锁。
    - [1]如果偏向锁的标识位为0，说明此时是处于无锁状态，则当前线程通过CAS操作尝试获取偏向锁，如果获取锁成功，则将Mark Word中的偏向线程ID设置为当前线程ID；并且将偏向标识位设为1。
    - [2]如果偏向锁的标识位不为1，也不为0(此时偏向锁的标识位没有值)，说明发生了竞争，偏向锁已经膨胀为轻量级锁，这时使用CAS操作尝试获得锁。
- 如果是偏向锁，则判断Mark Word中的偏向线程ID是否指向当前线程，如果偏向线程ID指向当前线程，则表明当前线程已经获取到了锁；
- 如果偏向线程ID并未指向当前线程，则通过CAS操作尝试获取偏向锁，如果获取锁成功，则将Mark Word中的偏向线程ID设置为当前线程ID；
- 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点时(在这个时间点上没有正在执行的字节码)，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。

偏向锁的释放：  
- 当其它的线程尝试获取偏向锁时，持有偏向锁的线程才会释放偏向锁。  
- 释放偏向锁需要等待全局安全点(在这个时间点上没有正在执行的字节码)。 
- 过程：
		首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，
		如果线程还活着，说明此时发生了竞争，则偏向锁升级为轻量级锁，然后刚刚被暂停的线程会继续往下执行同步代码。

优点：加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距

缺点：如果线程间存在锁竞争，锁撤销会带来额外的消耗。

说明：
- 偏向锁默认在应用程序启动几秒钟之后才激活。
- 可以通过设置 -XX:BiasedLockingStartupDelay=0 来关闭延迟。
- 可以通过设置 -XX:-UseBiasedLocking=false来关闭偏向锁，程序默认会进入轻量级锁状态。(如果应用程序里的锁大多情况下处于竞争状态，则应该将偏向锁关闭)

# 十三、多线程开发良好的实践

- 给线程起个有意义的名字，这样可以方便找 Bug。
- 缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。
- 多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。
- 使用 BlockingQueue 实现生产者消费者问题。
- 多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。
- 使用本地变量和不可变类来保证线程安全。
- 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。

# 十四、其他
## CAS (compare And Swap) 比较并且交换
> https://juejin.im/post/5ae753d8f265da0ba56753ca

## volatile
> https://mp.weixin.qq.com/s?__biz=MzIwNjg4MzY4NA==&mid=2247484841&idx=1&sn=6552e4baa34b8acb17055dc6eb3e62b9&chksm=971b9ba2a06c12b44d2bed66a3b195528b5f4af6ccc2efef719d3c24e0f35b5f2268bbd6a4ba&mpshare=1&scene=1&srcid=&sharer_sharetime=1589649317077&sharer_shareid=e863cc94aab1d6ed7f2a84f60f7152fb&key=5b117bc54371f384136814747489ba3909125ba75f98fb4a96f35572c0c6f492caff65a686a74673fbd3aed978b8551ab99f4a2b54cab59a9ab599f4f9e9e458515cc642ed02450f6b59865b459e888a&ascene=1&uin=MTk5NTA5NTgxNQ%3D%3D&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=A%2FwzWsP9LLm7luAHYB%2BqXzA%3D&pass_ticket=bH4zglYXveeNy6pMuZQZKRaJuaJd%2BbVPDEX1DeKtdBrrXPrhHTrsPgdQsZ9Wp2hq
### （1）保证可见性，不保证原子性
#### a.当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；

#### b.这个写会操作会导致其他线程中的缓存无效。
### （2）禁止指令重排

#### 重排序需要注意的点：
##### a.重排序操作不会对存在数据依赖关系的操作进行重排序。

##### b.重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变，多线程下重排序可能会影响结果。

比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。

#### volatile禁止重排序操作
使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序,volatile禁止指令重排序也有一些规则：

a.当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

b.在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

**即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。**

### volatile原理
volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：

I. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；

II. 它会强制将对缓存的修改操作立即写入主存；

III. 如果是写操作，它会导致其他CPU中对应的缓存行无效。